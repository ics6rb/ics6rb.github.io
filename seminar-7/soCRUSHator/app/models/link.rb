# frozen_string_literal: true

# Это класс модели, который будет реализовывать всю бизнес-логику, которую мы заложили в приложение.
# Одной модели вполне достаточно, потому что и бизнес-логики немного.
class Link < ApplicationRecord
  # Мы хотим проверять, что url валиден. По умолчанию в Rails-моделях нет такого валидатора, поэтому
  # мы напишем его сами (app/validators/correct_uri_validator.rb). Он подключается рельсовой магией:
  # 1) все, что лежи в app, зарекваерится автоматом, так что наш валидатор уже виден везде без доп. усилий;
  # 2) для того, чтобы валидатор был валидатором, его нужно наследовать от чего надо;
  # 3) чтобы модели были доступны валидаторы, надо примешать ActiveModel::Validations; можно было и в
  # ApplicationRecord, но мы соберем все в одном месте для наглядности.
  # Наконец, валидатором можно пользоваться, НО тут в дело опять вступает рельсовая магия - валидатор
  # нигде не вызывается напрямую, однако если передать в качестве аргумента в validates название валидатора,
  # ОНО ЗАРАБОТАЕТ!!! Мы назвали валидатор CorrectUriValidator, значит, передавать нужно correct_uri: true.
  include ActiveModel::Validations

  # Сколько элементов выводить на страницу по умолчанию - просто чтобы быстрее увидеть пагинацию.
  paginates_per 5

  # Методы, которые выполняют проверки ограничений бизнес-логики.
  # В нашем случае необходимо, чтобы url и slug были определены, а также чтобы slug был уникальным.
  # Эти проверки делаются КОДОМ. Иными словами, код генерирует запросы к БД.
  # Например, проверка уникальности - это SELECT * FROM links WHERE slug = ? LIMIT 1; - если есть
  # хотя бы одна запись с тем же slug, проверка не пройдет.
  # Однако нужно понимать, что это ненадежная проверка, и она может не сработать при конкурентном
  # доступе к БД.
  # Именно поэтому мы добавили еще одну миграцию, в которой сделали уникальный индекс по slug.
  # Ко всему прочему, это позволит искать ссылки по slug (читай - делать редирект) быстрее.
  validates :url, presence: true, correct_uri: true
  validates :slug, presence: true, uniqueness: true

  # Это просто идиоматичный способ создать статический метод
  class << self
    # С помощью этого метода будем создавать новые ссылки.
    def create_from_link(link)
      # create - это то же самое, что Link.create; метод наследуется от ActiveRecord::Base.
      create url: link, slug: Nanoid.generate(size: 10)
    end

    # Занесем бизнес-логику в модель - нашли, увеличили счетчик просмотров, вернули.
    def find_and_increment_clicks(slug)
      link = find_by slug: slug
      return link unless link

      link.clicks += 1
      link.save

      link
    end
  end
end
